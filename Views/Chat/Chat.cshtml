@model dynamic
@{
	Layout = "~/Views/Shared/_Layout.cshtml";
	ViewData["Title"] = "Chat";
}
<style>
	/* estilo ajustado para ficar similar ao protótipo */
	.chat-page { display:flex; flex-direction:column; align-items:center; padding:40px 0; background:transparent; }
	.chat-card {
		background:#13202a; border-radius:18px; padding:28px; width:760px; color:#fff; box-shadow:0 10px 0 rgba(0,0,0,0.4);
	}
	.header { display:flex; align-items:center; justify-content:center; gap:18px; margin-bottom:18px; }
	.header .logo { height:78px; }
	.header .meta { color:#fff; font-size:15px; }
	.header .meta strong { margin-right:10px; font-weight:600; }

	.chat-inner {
		background:#ffffff; color:#111; border-radius:12px; padding:18px; height:420px;
		display:flex; flex-direction:column; overflow:hidden; position:relative; z-index:1;
	}
	.messages {
		flex:1; overflow-y:auto; padding:8px; display:flex; flex-direction:column; gap:12px;
		word-wrap:break-word; white-space:pre-wrap; position:relative; z-index:2;
	}
	/* linha com data/hora acima e bolha abaixo */
	.msg-row { display:flex; flex-direction:column; gap:4px; }
	.msg-row.left { align-items:flex-start; }
	.msg-row.right { align-items:flex-end; }
	.msg-row .meta-time { font-size:11px; color:#666; margin:0 6px; }
	.msg {
		max-width:66%; border-radius:10px; font-size:13px; line-height:1.2;
		position:relative; display:inline-block; width:fit-content;
		padding:10px 12px;
		box-shadow: 0 1px 0 rgba(0,0,0,0.04);
		overflow-wrap:break-word;
	}
	.msg.assistant {
		background:#dcdcdc; color:#000; align-self:flex-start; border-bottom-left-radius:6px;
	}
	.msg.client {
		background:#bfc6cc; color:#000; align-self:flex-end; border-bottom-right-radius:6px;
	}

	.chat-input-bar {
		display:flex; align-items:center; gap:8px; margin-top:14px;
		background:transparent; padding:6px 6px 0 6px;
	}
	.input-wrap {
		flex:1; background:#f1f3f5; border-radius:999px; padding:8px 12px; display:flex; align-items:center; gap:8px;
	}
	.btn-round { width:36px; height:36px; display:inline-flex; align-items:center; justify-content:center; border-radius:50%; background:#fff; color:#333; cursor:pointer; border:0; }
	.chat-input { flex:1; border:0; outline:none; background:transparent; font-size:14px; color:#111; }
	.send-btn { background:#0f2430; color:#fff; border-radius:999px; border:0; padding:8px 14px; cursor:pointer; }

	.back-btn { display:block; margin:18px auto 0; background:#fff; color:#000; padding:10px 28px; border-radius:8px; text-decoration:none; text-align:center; width:220px; }

	/* responsivo */
	@@media (max-width:760px) {
		.chat-card { width:94%; padding:16px; }
		.header .logo { height:56px; }
	}
</style>

<div class="chat-page">
	<!-- Logo maior fora do card -->
	<div style="text-align:center; margin-bottom:14px;">
		<img src="/images/logoh.png" alt="HelpFast" style="height:96px; width:auto;" />
	</div>
	<div class="chat-card">
		<!-- Cabeçalho com ID à esquerda e Motivo à direita -->
		<div class="header" style="justify-content:space-between;">
			<div class="meta" style="display:flex; gap:18px; align-items:center;">
				<div><strong>ID Chamado:</strong> <span>@ViewBag.ChamadoId</span></div>
			</div>
			<div class="meta" style="text-align:right;"><strong>Motivo:</strong> <span>@ViewBag.Motivo</span></div>
		</div>
 
 		<!-- root com dados do chamado disponíveis para o JS -->
		<div class="chat-inner" id="chat-root"
		     data-chamado-id="@((ViewBag.ChamadoNumericId ?? ""))"
		     data-motivo="@((ViewBag.Motivo ?? ""))">
			<div class="messages" id="messages" aria-live="polite" aria-atomic="false">
				<!-- mensagem inicial: usa resposta retornada pelo controller (ViewBag.InitialBotMessage) quando disponível -->
				@if (!string.IsNullOrEmpty((string?)ViewBag.InitialBotMessage))
				{
					<div class="msg-row left">
						<div class="meta-time">@DateTime.Now.ToString("dd/MM/yyyy HH:mm")</div>
						<div class="msg assistant">
							<div><strong>Assistente</strong></div>
							<div>@ViewBag.InitialBotMessage</div>
						</div>
					</div>
				}
				else
				{
					<div class="msg-row left">
						<div class="meta-time">@DateTime.Now.ToString("dd/MM/yyyy HH:mm")</div>
						<div class="msg assistant">
							<div><strong>Assistente</strong></div>
							<div>Olá, sou o Assistente Virtual do Help Fast. Como posso te ajudar?</div>
						</div>
					</div>
				}
			</div>

			<div class="chat-input-bar" aria-hidden="false">
				<div class="input-wrap">
					<input id="chat-input" class="chat-input" placeholder="Digite aqui:" aria-label="Digite sua mensagem" />
					<button type="button" class="btn-round" id="btn-send-icon" title="Enviar">✈</button>
				</div>
			</div>
		</div>
 
		<a class="back-btn" href="@Url.Action("Index","Home")">Voltar ao menu</a>
	</div>
</div>

@section Scripts {
	<script>
		document.addEventListener('DOMContentLoaded', async function(){
			const webhookUrl = '/Chat/Send';
			const root = document.getElementById('chat-root');
			const messagesEl = document.getElementById('messages');
			const inputEl = document.getElementById('chat-input');
			const sendIcon = document.getElementById('btn-send-icon');

			if (!root || !messagesEl || !inputEl || !sendIcon) {
				console.error('Elementos do chat não encontrados.');
				return;
			}

			const chamadoId = root.dataset.chamadoId || null;
			const motivo = root.dataset.motivo || '';
			let hasTechnician = false;
			let assignedToTech = false; // evita chamadas/avisos duplicados de transferência
			let lastMaxId = 0;
			const renderedIds = new Set();
			let assistantResponseCount = 0; // Contador de respostas do assistente
			const MAX_ASSISTANT_RESPONSES = 3; // Limite de respostas antes de transferir

			function formatTime(date = new Date()){
				const d = date;
				return d.toLocaleDateString('pt-BR') + ' ' + d.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'});
			}

			function appendMessage(type, text){
				const bubble = document.createElement('div');
				bubble.className = 'msg ' + (type === 'me' ? 'client' : 'assistant');
				const strong = document.createElement('div');
				strong.innerHTML = type === 'me' ? '<strong>Você</strong>' : '<strong>Assistente</strong>';
				const body = document.createElement('div');
				body.innerText = text;
				bubble.appendChild(strong);
				bubble.appendChild(body);

				const row = document.createElement('div');
				row.className = 'msg-row ' + (type === 'me' ? 'right' : 'left');
				const timeTop = document.createElement('div');
				timeTop.className = 'meta-time';
				timeTop.innerText = formatTime();
				row.appendChild(timeTop);
				row.appendChild(bubble);
				messagesEl.appendChild(row);
				
				// Scroll suave para o final
				setTimeout(() => {
					messagesEl.scrollTop = messagesEl.scrollHeight;
				}, 0);
			}

			function appendFromServer(msg){
				const id = msg.Id ?? msg.id; if (id && renderedIds.has(id)) return;
				const tipo = msg.Tipo ?? msg.tipo;
				const mensagem = msg.Mensagem ?? msg.mensagem;
				const dataEnvio = msg.DataEnvio ?? msg.dataEnvio;
				if (!tipo || !mensagem) return;

				const bubble = document.createElement('div');
				bubble.className = 'msg ' + (tipo === 'Usuario' ? 'client' : 'assistant');
				const strong = document.createElement('div');
				const whoLabel = (tipo === 'Usuario') ? 'Você' : (tipo === 'Tecnico' ? 'Técnico' : 'Assistente');
				strong.innerHTML = `<strong>${whoLabel}</strong>`;
				const body = document.createElement('div');
				body.innerText = mensagem;
				bubble.appendChild(strong);
				bubble.appendChild(body);

				const row = document.createElement('div');
				row.className = 'msg-row ' + (tipo === 'Usuario' ? 'right' : 'left');
				row.dataset.msgId = id;
				const timeTop = document.createElement('div');
				timeTop.className = 'meta-time';
				const dt = new Date(dataEnvio);
				timeTop.innerText = dt.toLocaleDateString('pt-BR') + ' ' + dt.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
				row.appendChild(timeTop);
				row.appendChild(bubble);
				messagesEl.appendChild(row);

				if (id) { renderedIds.add(id); lastMaxId = Math.max(lastMaxId, id); }
				setTimeout(() => { messagesEl.scrollTop = messagesEl.scrollHeight; }, 0);
			}

			// Carregar histórico ao abrir a página (somente ao carregar, não depois)
			async function loadHistory() {
				if (!chamadoId || chamadoId === '') {
					console.log('Sem chamadoId, pulando carregamento de histórico');
					return;
				}
				
				try {
					console.log('Carregando histórico para chamadoId:', chamadoId);
					const res = await fetch(`/Chat/History/${chamadoId}`);
					if (!res.ok) {
						console.log('Erro na requisição do histórico:', res.status);
						return;
					}
					
					const data = await res.json();
					console.log('Dados do histórico recebidos:', data);
					
					if (data.success && data.messages && data.messages.length > 0) {
						console.log('Carregando histórico, total de mensagens:', data.messages.length);
						// Limpar TODAS as mensagens (incluindo a padrão "Olá...")
						messagesEl.innerHTML = '';
						
						// Recarregar com histórico
						data.messages.forEach(msg => appendFromServer(msg));

						// Verificar se já tem técnico pelo histórico (se houver tipo explícito)
						hasTechnician = data.messages.some(m => (m.Tipo ?? m.tipo) === 'Tecnico');
						if (hasTechnician) assignedToTech = true;
						// Inicializar lastMaxId
						const maxIdNow = Math.max.apply(null, data.messages.map(m => m.Id ?? m.id));
						if (Number.isFinite(maxIdNow)) lastMaxId = maxIdNow;
						
						// Scroll para o final
						setTimeout(() => {
							messagesEl.scrollTop = messagesEl.scrollHeight;
						}, 100);
				} else {
						console.log('Nenhuma mensagem no histórico, mantendo mensagem padrão');
					}
				} catch (e) {
					console.error('Erro ao carregar histórico:', e);
				}
			}

			// Flag para controlar carregamento
			let historyLoaded = false;
			let initialMessageShown = true;

			// Carregar histórico uma única vez ao inicializar
			await loadHistory();
			historyLoaded = true;
			console.log('Histórico carregado, historyLoaded =', historyLoaded);

			let sending = false;
			async function sendMessage(){
				if (sending) return;
				const text = inputEl.value.trim();
				if (!text) return;

				appendMessage('me', text);
				inputEl.value = '';

				sending = true;
				sendIcon.setAttribute('disabled','disabled');

				try {
					const payload = { message: text, chamadoId: chamadoId ? parseInt(chamadoId,10) : null, motivo: motivo };
					console.log('Enviando payload:', payload);
					
					const res = await fetch(webhookUrl, { 
						method: 'POST', 
						headers: { 'Content-Type': 'application/json' }, 
						body: JSON.stringify(payload) 
					});

					const data = await res.json();
					console.log('Resposta do servidor:', data);

					// Se tem técnico atribuído, não precisa fazer polling
					if (data && data.hasTechnician) {
						console.log('Chamado tem técnico atribuído. Mensagem salva e será vista pelo técnico. Parando conversa com assistente.');
						hasTechnician = true;
						assignedToTech = true;
						if (data.chatId) { 
							lastMaxId = Math.max(lastMaxId, data.chatId); 
							renderedIds.add(data.chatId); 
						}
						sending = false;
						sendIcon.removeAttribute('disabled');
						return;
					}

					// Se o servidor respondeu com processing:true, iniciar polling
					if (data && data.processing && data.chatId) {
						console.log('Iniciando polling para chatId:', data.chatId);
						lastMaxId = Math.max(lastMaxId, data.chatId); 
						renderedIds.add(data.chatId);
						
						const startTime = Date.now();
						const timeout = 150000; // 150s
						let found = false;
						let tentativas = 0;
						let isPolling = true;

						// helper: atribui técnico e envia mensagem apenas uma vez
						async function transferToTechnicianOnce(motivoTransferencia){
							if (assignedToTech) return;
							appendMessage('assistant', 'Estamos te transferindo para um Técnico, aguarde um momento.');
							if (chamadoId) {
								try {
									const assignRes = await fetch(`/Chat/AssignToTechnician/${chamadoId}`, { method: 'POST' });
									const assignData = await assignRes.json();
									if (assignData.success) {
										console.log('Chamado atribuído ao técnico (motivo:', motivoTransferencia, '):', assignData.tecnicoNome);
										assignedToTech = true;
										hasTechnician = true;
									}
								} catch (e) { console.error('Erro ao atribuir técnico:', e); }
							}
						}

						while ((Date.now() - startTime) < timeout && !found && !assignedToTech) {
							tentativas++;
							await new Promise(r => setTimeout(r, 800));
							
							try {
								const pollRes = await fetch(`/Chat/AssistantReplyForChat/${data.chatId}`);
								const pollData = await pollRes.json();
								
								console.log(`Tentativa ${tentativas}:`, pollData);

								if (pollData && pollData.found && pollData.message && pollData.message.trim() !== '') {
									console.log('Resposta encontrada!', pollData.message);
									
									// Verificar se é "sem resposta"
									const msgLower = pollData.message.toLowerCase();
									if (msgLower.includes('sem resposta') || msgLower.includes('não consegui') || msgLower.includes('nao consegui')) {
										console.log('IA não conseguiu responder, transferindo para técnico...');
										await transferToTechnicianOnce('sem-resposta');
									} else {
										// Incrementar contador de respostas do assistente
										assistantResponseCount++;
										console.log(`Resposta do assistente ${assistantResponseCount}/${MAX_ASSISTANT_RESPONSES}`);
										
										// Mostrar resposta normal
										const cleanMessage = pollData.message.trim();
										console.log('Resposta limpa do assistente:', cleanMessage);
										appendMessage('assistant', cleanMessage);
										if (pollData.assistantChatId) { 
											lastMaxId = Math.max(lastMaxId, pollData.assistantChatId); 
											renderedIds.add(pollData.assistantChatId); 
										}

										// Verificar se atingiu o limite de respostas
										if (assistantResponseCount >= MAX_ASSISTANT_RESPONSES) {
											console.log('Limite de respostas do assistente atingido, transferindo para técnico...');
											await transferToTechnicianOnce('limite-respostas');
										}
									}
									
									found = true;
									break;
								}
							} catch (e) {
								console.error(`Tentativa ${tentativas}: Erro ao fazer polling:`, e);
							}
						}

						if (!found && !assignedToTech) {
							console.log('Timeout atingido - nenhuma resposta encontrada, transferindo para técnico');
							await transferToTechnicianOnce('timeout');
						}
						
						isPolling = false;
					} else {
						console.log('Resposta direta do servidor (sem polling necessário)');
						const msg = (data && (data.reply || data.message || data.text)) || 'Sem resposta';
						appendMessage('assistant', msg);
					}
				} catch (err) {
					console.error('Erro ao enviar mensagem:', err);
					appendMessage('assistant', 'Erro ao enviar mensagem. Tente novamente.');
				} finally {
					sending = false;
					sendIcon.removeAttribute('disabled');
				}
			}

			// Enter envia
			inputEl.addEventListener('keydown', function(e){
				if (e.key === 'Enter' && !e.shiftKey) {
					e.preventDefault();
					sendMessage();
				}
			});

			// clique no avião envia
			sendIcon.addEventListener('click', sendMessage);

			inputEl.focus();

			// Auto refresh: busca novas mensagens e adiciona apenas as com id maior
			async function refreshLoop(){
				if (!chamadoId || sending) return; // Não atualiza enquanto está enviando
				try {
					const res = await fetch(`/Chat/History/${chamadoId}`);
					if (!res.ok) return;
					const data = await res.json();
					if (data && data.success && Array.isArray(data.messages)){
						data.messages.forEach(m => {
							const id = m.Id ?? m.id; 
							if (!id) return; 
							if (renderedIds.has(id)) return; // Verifica se já foi renderizado
							if (id <= lastMaxId) return; 
							appendFromServer(m);
						});
					}
				} catch (e) {
					console.error('Erro no refreshLoop:', e);
				}
			}
			const intervalId = setInterval(refreshLoop, 2000);
			// status polling: finalizado/cancelado
			async function statusLoop(){
				if (!chamadoId) return;
				try{
					const r = await fetch(`/Chamados/Status/${chamadoId}`);
					if(!r.ok) return; const d = await r.json();
					if (d && d.success && typeof d.status === 'string'){
						const status = d.status;
						if (status === 'Finalizado'){
							clearInterval(intervalId); clearInterval(statusTimer);
							window.location.href = `/Chamados/ChamadoFinalizado/${chamadoId}`;
							return;
						}
						if (status === 'Cancelado'){
							clearInterval(intervalId); clearInterval(statusTimer);
							window.location.href = '/Home/Index';
							return;
						}
					}
				}catch{}
			}
			const statusTimer = setInterval(statusLoop, 2000);
			window.addEventListener('beforeunload', ()=> { clearInterval(intervalId); clearInterval(statusTimer); });
		});
	</script>
}
